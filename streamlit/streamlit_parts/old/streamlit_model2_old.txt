%%writefile pages/3_Machine_Learning_Modell_II.py
import streamlit as st
import pandas as pd
import numpy as np
import joblib  # Zum Laden gespeicherter Modelle
import matplotlib.pyplot as plt
import seaborn as sns
import os
import plotly.express as px
from plotly.subplots import make_subplots

#Pfad festlegen
os.chdir('C:/Users/Katharina/Desktop/Weiterbildung/Bootcamp/Bootcamp/Final_project/streamlit_parts')


# Setze den gewünschten Seitentitel, das Icon und Layout (optional)
st.set_page_config(
    page_title="Prediction of individual statistical values of one team",  # Hier stellst du den angezeigten Namen ein
    #page_icon=":smile:",                # Optional: Icon der Seite
    layout="centered"
)

st.title("Prediction of individual statistical values of one team")
#st.write("This is the second Machine Learning Model.")
st.markdown("""
Here it is possible to choose between thematically different models:

- Sum of total Spikes in one game with weather impact (Random Forest & GradientBoosting)
- Sum of total Spikes in one game without weather impact (Random Forest & GradientBoosting)

You can also set different values for the filters.
""")
#Daten für SpikeFault
df_Reg_mitW = pd.read_csv('ML_SpikeFault_mitWetter_V2.csv', sep=';')
df_Reg_ohneW = pd.read_csv('ML_SpikeFault_OHNEWetter_V2.csv', sep=';')

#Daten für SpikePoint
df_SpikeSum_mitW = pd.read_csv('ML_SpikePoint_MitWetter.csv', sep=';')
df_SpikeSum_mitW = df_SpikeSum_mitW.rename(columns={'Standard_Namen': 'Team1', 'Standard_Namen_team2': 'Team2'})
df_SpikeSum_ohneW = pd.read_csv('ML_SpikePoint_OHNEWetter.csv', sep=';')
df_SpikeSum_ohneW = df_SpikeSum_ohneW.rename(columns={'Standard_Namen': 'Team1', 'Standard_Namen_team2': 'Team2'})

#Modelle implementieren

model_choice = st.sidebar.selectbox('Choose the model', [#'Spike-Fault with weather impact (Random Forest)', 'Spike-Fault with weather impact (Gradient Boosting)',
                                                        #'Spike-Fault without weather impact (Random Forest)', 'Spike-Fault without weather impact (Gradient Boosting)',
                                                        'Total-Spikes with weather impact (Random Forest)','Total-Spikes with weather impact (Gradient Boosting)',
                                                        'Total-Spikes without weather impact (Random Forest)','Total-Spikes without weather impact (Gradient Boosting)'])

#Lade das Model und die relevanten Daten
# if model_choice ==  'Spike-Fault with weather impact (Random Forest)':
#     model = joblib.load('RandomForest_SpikeFault_mitWetter.pkl')
#     df = df_Reg_mitW
#     target_variable = 'SpikeFault'
# elif model_choice == 'Spike-Fault with weather impact (Gradient Boosting)': 
#     model = joblib.load('GradientBoosting_SpikeFault_mitWetter.pkl')
#     df = df_Reg_mitW
#     target_variable = 'SpikeFault'

# elif model_choice == 'Spike-Fault without weather impact (Random Forest)':
#     model = joblib.load('RandomForest_SpikeFault_OHNEWetter.pkl')
#     df = df_Reg_ohneW
#     target_variable = 'SpikeFault'

# elif model_choice == 'Spike-Fault without weather impact (Gradient Boosting)': 
#     model = joblib.load('GradientBoosting_SpikeFault_OHNEWetter.pkl')
#     df = df_Reg_ohneW
#     target_variable = 'SpikeFault'

##SpikeTotal
if model_choice == 'Total-Spikes with weather impact (Random Forest)': 
    model = joblib.load('RandomForest_SpikePoint_mitWetter_OhneStatistikDaten2.pkl')
    df = df_SpikeSum_mitW
    target_variable = 'SpikePoint'
elif model_choice == 'Total-Spikes with weather impact (Gradient Boosting)': 
    model = joblib.load('GradientBoosting_SpikePoint_mitWetter_OhneStatistikDaten2.pkl')
    df = df_SpikeSum_mitW
    target_variable = 'SpikePoint'
elif model_choice == 'Total-Spikes without weather impact (Random Forest)': 
    model = joblib.load('RandomForest_SpikePoint_OHNEWetter_OhneStatistikDaten.pkl')
    df = df_SpikeSum_ohneW
    target_variable = 'SpikePoint'
else : 
    model = joblib.load('GradientBoosting_SpikePoint_OHNEWetter_OhneStatistikDaten.pkl')
    df = df_SpikeSum_ohneW
    target_variable = 'SpikePoint'

st.write(f'You have choosen:** {model_choice}')


#---------------------------------------------------------
###########################################################
#Filter Geschlecht
###########################################################
#Gender neu definieren
df['Gender_x'] = df['Gender_x'].astype(int)
#Mapping
gender_mapping = {
    0: 'male',
    1: 'female'
}
original_gender_values = df['Gender_x'].unique()
display_options = [gender_mapping.get(g, g) for g in original_gender_values]

selected_gender_display = st.sidebar.selectbox("Choose Gender", display_options)

# Um das inverse Mapping zu erstellen, damit wir den Originalwert erhalten:
inverse_mapping = {v: k for k, v in gender_mapping.items()}
selected_gender = inverse_mapping.get(selected_gender_display, selected_gender_display)

# ------------------
# Anwenden der Filter
# ------------------
# Kombiniere beide Filter: Geschlecht und Turnier-Typ
df_filtered = df[(df["Gender_x"] == selected_gender)]

# Eingabeformular für Benutzer
st.sidebar.header('Choose Variables')

input_data = {}
# if model_choice == 'Spike-Fault with weather impact (Random Forest)':
#     temperature_val = st.sidebar.slider("Temperature",  float(df_filtered["temperature_2m"].min()),  float(df_filtered["temperature_2m"].max()))
#     wind_speed_val = st.sidebar.slider( "Wind Speed", float(df_filtered["wind_speed_10m"].min()), float(df_filtered["wind_speed_10m"].max()))
#     wind_gusts_val = st.sidebar.slider( "Wind Gusts", float(df_filtered["wind_gusts_10m"].min()), float(df_filtered["wind_gusts_10m"].max()))
#     rain_val = st.sidebar.slider("Rain", float(df_filtered["rain"].min()), float(df_filtered["rain"].max()))

#     # # Abfrage, ob ein dritter Satz berücksichtigt werden soll
#     # third_set_selection = st.sidebar.selectbox("Third Set?", options=["No", "Yes"])
#     # third_set_value = 1 if third_set_selection == "Yes" else 0


#     # # Abhängig vom ThirdSet-Wert den Slider für @DurationSet3 anzeigen
#     # if third_set_value == 1:
#     #     # Filtere den DataFrame nach Zeilen, bei denen der Indikator 1 ist
#     #     df_third_filtered = df_filtered[df_filtered["@DurationSet3_indicator"] == 1]
#     #     # Prüfe, ob gültige (nicht-NA) Werte in der Spalte '@DurationSet3' vorhanden sind
#     #     if df_third_filtered.empty or df_third_filtered['@DurationSet3'].dropna().empty:
#     #         st.sidebar.error("Für 'Third Set = Yes' sind keine gültigen Werte für Duration Set3 vorhanden.")
#     #         duration_val = 0.0
#     #     else:
#     #         duration_min = float(df_third_filtered['@DurationSet3'].min())
#     #         duration_max = float(df_third_filtered['@DurationSet3'].max())
#     #         duration_val = st.sidebar.slider("Duration Set3", duration_min, duration_max)
#     # else:
#     #     duration_val = 0.0
#     #     st.sidebar.info("Duration Set3 is set to 0 because Third Set is not selected.")



#     # Team-Auswahl (unabhängig vom Third Set Filter – oder auch hier ggf. anpassen)
#     team1_selection = st.sidebar.selectbox("Team 1", df_filtered["Team1"].unique())

#     # Zusammenstellung der Eingabedaten – beachte, dass die Schlüssel exakt den im Modell verwendeten Spaltennamen entsprechen müssen.
#     input_data = {
#     "temperature_2m": temperature_val,
#     "wind_speed_10m": wind_speed_val,
#     "wind_gusts_10m": wind_gusts_val,
#     "rain": rain_val,
#     #"@DurationSet3": duration_val,          # Vom Slider (oder automatisch 0)
#     #"@DurationSet3_indicator": third_set_value,             # 1 bei Third Set = Yes, sonst 0
#     "Team1": team1_selection
#     }
# elif model_choice =='Spike-Fault with weather impact (Gradient Boosting)':

#     temperature_val = st.sidebar.slider("Temperature",  float(df_filtered["temperature_2m"].min()),  float(df_filtered["temperature_2m"].max()))
#     wind_speed_val = st.sidebar.slider( "Wind Speed", float(df_filtered["wind_speed_10m"].min()), float(df_filtered["wind_speed_10m"].max()))
#     wind_gusts_val = st.sidebar.slider( "Wind Gusts", float(df_filtered["wind_gusts_10m"].min()), float(df_filtered["wind_gusts_10m"].max()))
#     rain_val = st.sidebar.slider("Rain", float(df_filtered["rain"].min()), float(df_filtered["rain"].max()))

#     # # Abfrage, ob ein dritter Satz berücksichtigt werden soll
#     # third_set_selection = st.sidebar.selectbox("Third Set?", options=["No", "Yes"])
#     # third_set_value = 1 if third_set_selection == "Yes" else 0

#     # # Falls Third Set = Yes (also third_set_value==1), dann kann der Slider für DurationSet3 angezeigt werden.
#     # if third_set_value == 1:
#     #     # Filtere den DataFrame basierend auf DurationSet3_indicator
#     #     df_third_filtered = df_filtered[df_filtered["@DurationSet3_indicator"] == third_set_value]
#     #     if not df_third_filtered.empty:
#     #         duration_min = float(df_third_filtered['@DurationSet3'].min())
#     #         duration_max = float(df_third_filtered['@DurationSet3'].max())
#     #     else:
#     #         duration_min, duration_max = 0.0, 0.0

#     #     duration_val = st.sidebar.slider('Duration Set3', duration_min, duration_max)
#     # else:
#     #     # Wenn kein Third Set ausgewählt wurde, setzen wir DurationSet3 automatisch auf 0
#     #     duration_val = 0.0

#     # Team-Auswahl (unabhängig vom Third Set Filter – oder auch hier ggf. anpassen)
#     team1_selection = st.sidebar.selectbox("Team 1", df_filtered["Team1"].unique())

#     # Zusammenstellung der Eingabedaten – beachte, dass die Schlüssel exakt den im Modell verwendeten Spaltennamen entsprechen müssen.
#     input_data = {
#     "temperature_2m": temperature_val,
#     "wind_speed_10m": wind_speed_val,
#     "wind_gusts_10m": wind_gusts_val,
#     "rain": rain_val,
#     #"@DurationSet3": duration_val,          # Vom Slider (oder automatisch 0)
#     #"@DurationSet3_indicator": third_set_value,             # 1 bei Third Set = Yes, sonst 0
#     "Team1": team1_selection
#     }




# elif model_choice =='Spike-Fault without weather impact (Random Forest)':
#     ServeFault_val =  st.sidebar.slider("ServeFault", int(df_filtered["ServeFault"].min()), int(df_filtered["ServeFault"].max()))
#     ServeTotal_val =  st.sidebar.slider("ServeTotal", int(df_filtered["ServeTotal"].min()), int(df_filtered["ServeTotal"].max()))
#     BlockTotal_val = st.sidebar.slider("BlockTotal", int(df_filtered["BlockTotal"].min()), int(df_filtered["BlockTotal"].max()))
    
#     # Abfrage, ob ein dritter Satz berücksichtigt werden soll
#     third_set_selection = st.sidebar.selectbox("Third Set?", options=["No", "Yes"])
#     third_set_value = 1 if third_set_selection == "Yes" else 0

#     # Falls Third Set = Yes (also third_set_value==1), dann kann der Slider für DurationSet3 angezeigt werden.
#     if third_set_value == 1:
#         # Filtere den DataFrame basierend auf DurationSet3_indicator
#         df_third_filtered = df_filtered[df_filtered["@DurationSet3_indicator"] == third_set_value]
#         if not df_third_filtered.empty:
#             duration_min = float(df_third_filtered['@DurationSet3'].min())
#             duration_max = float(df_third_filtered['@DurationSet3'].max())
#         else:
#             duration_min, duration_max = 0.0, 0.0

#         duration_val = st.sidebar.slider('Duration Set3', duration_min, duration_max)
#     else:
#         # Wenn kein Third Set ausgewählt wurde, setzen wir DurationSet3 automatisch auf 0
#         duration_val = 0.0

#     # Team-Auswahl (unabhängig vom Third Set Filter – oder auch hier ggf. anpassen)
#     team1_selection = st.sidebar.selectbox("Team 1", df_filtered["Team1"].unique())

#     # Zusammenstellung der Eingabedaten – beachte, dass die Schlüssel exakt den im Modell verwendeten Spaltennamen entsprechen müssen.
#     input_data = {
#     "ServeFault": ServeFault_val,
#     "ServeTotal": ServeTotal_val,
#     "BlockTotal": BlockTotal_val,
#     "@DurationSet3": duration_val,          # Vom Slider (oder automatisch 0)
#     "@DurationSet3_indicator": third_set_value,             # 1 bei Third Set = Yes, sonst 0
#     "Team1": team1_selection
#     }


# elif model_choice =='Spike-Fault without weather impact (Gradient Boosting)':
    
#     ServeFault_val = st.sidebar.slider("ServeFault", int(df_filtered["ServeFault"].min()), int(df_filtered["ServeFault"].max())),
#     ServeTotal_val = st.sidebar.slider("ServeTotal", int(df_filtered["ServeTotal"].min()), int(df_filtered["ServeTotal"].max())),
#     BlockTotal_val = st.sidebar.slider("BlockTotal", int(df_filtered["BlockTotal"].min()), int(df_filtered["BlockTotal"].max()))
    
#     # Abfrage, ob ein dritter Satz berücksichtigt werden soll
#     third_set_selection = st.sidebar.selectbox("Third Set?", options=["No", "Yes"])
#     third_set_value = 1 if third_set_selection == "Yes" else 0

#     # Falls Third Set = Yes (also third_set_value==1), dann kann der Slider für DurationSet3 angezeigt werden.
#     if third_set_value == 1:
#         # Filtere den DataFrame basierend auf DurationSet3_indicator
#         df_third_filtered = df_filtered[df_filtered["@DurationSet3_indicator"] == third_set_value]
#         if not df_third_filtered.empty:
#             duration_min = float(df_third_filtered['@DurationSet3'].min())
#             duration_max = float(df_third_filtered['@DurationSet3'].max())
#         else:
#             duration_min, duration_max = 0.0, 0.0

#         duration_val = st.sidebar.slider('Duration Set3', duration_min, duration_max)
#     else:
#         # Wenn kein Third Set ausgewählt wurde, setzen wir DurationSet3 automatisch auf 0
#         duration_val = 0.0

#     # Team-Auswahl (unabhängig vom Third Set Filter – oder auch hier ggf. anpassen)
#     team1_selection = st.sidebar.selectbox("Team 1", df_filtered["Team1"].unique())

#     # Zusammenstellung der Eingabedaten – beachte, dass die Schlüssel exakt den im Modell verwendeten Spaltennamen entsprechen müssen.
#     input_data = {
#     "ServeFault": ServeFault_val,
#     "ServeTotal": ServeTotal_val,
#     "BlockTotal": BlockTotal_val,
#     "@DurationSet3": duration_val,          # Vom Slider (oder automatisch 0)
#     "@DurationSet3_indicator": third_set_value,             # 1 bei Third Set = Yes, sonst 0
#     "Team1": team1_selection
#     }

###
#-Spike total models
if model_choice =='Total-Spikes with weather impact (Random Forest)':
    # Wetterparameter
    temperature_val = st.sidebar.slider("Temperature",  float(df_filtered["temperature_2m"].min()),  float(df_filtered["temperature_2m"].max()))
    wind_speed_val = st.sidebar.slider( "Wind Speed", float(df_filtered["wind_speed_10m"].min()), float(df_filtered["wind_speed_10m"].max()))
    wind_gusts_val = st.sidebar.slider( "Wind Gusts", float(df_filtered["wind_gusts_10m"].min()), float(df_filtered["wind_gusts_10m"].max()))

    # Abfrage, ob ein dritter Satz berücksichtigt werden soll
    third_set_selection = st.sidebar.selectbox("Third Set?", options=["No", "Yes"])
    third_set_value = 1 if third_set_selection == "Yes" else 0

    # Falls Third Set = Yes (also third_set_value==1), dann kann der Slider für DurationSet3 angezeigt werden.
    if third_set_value == 1:
        # Filtere den DataFrame basierend auf DurationSet3_indicator
        df_third_filtered = df_filtered[df_filtered["@DurationSet3_indicator"] == third_set_value]
        if not df_third_filtered.empty:
            duration_min = float(df_third_filtered['@DurationSet3'].min())
            duration_max = float(df_third_filtered['@DurationSet3'].max())
        else:
            duration_min, duration_max = 0.0, 0.0

        duration_val = st.sidebar.slider('Duration Set3', duration_min, duration_max)
    else:
        # Wenn kein Third Set ausgewählt wurde, setzen wir DurationSet3 automatisch auf 0
        duration_val = 0.0

    # Team-Auswahl (unabhängig vom Third Set Filter – oder auch hier ggf. anpassen)
    team1_selection = st.sidebar.selectbox("Team 1", df_filtered["Team1"].unique())

    # Zusammenstellung der Eingabedaten – beachte, dass die Schlüssel exakt den im Modell verwendeten Spaltennamen entsprechen müssen.
    input_data = {
        # Diese Felder werden interaktiv gefiltert:
        "temperature_2m": temperature_val,
        "wind_speed_10m": wind_speed_val,
        "wind_gusts_10m": wind_gusts_val,
        "@DurationSet3": duration_val,
        "@DurationSet3_indicator": third_set_value,
        "Team1": team1_selection,
        
        # Ergänzende Felder (Standardwerte aus df_filtered):
        "@PositionInEntry": float(df_filtered["@PositionInEntry"].mean()),
        "@Rank": int(df_filtered["@Rank"].median()),
        "@EarnedPointsTeam": float(df_filtered["@EarnedPointsTeam"].mean()),
        "@EarningsTotalTeam": float(df_filtered["@EarningsTotalTeam"].mean()),
        "Gender_x": df_filtered["Gender_x"].mode()[0],
        "Type": df_filtered["Type"].mode()[0],
        #"FederationCode_y": df_filtered["FederationCode_y"].mode()[0],
        "FirstName": df_filtered["FirstName"].iloc[0],
        "LastName": df_filtered["LastName"].iloc[0],
        "FirstName2": df_filtered["FirstName2"].iloc[0],
        "LastName2": df_filtered["LastName2"].iloc[0],
        "@DurationSet1": float(df_filtered["@DurationSet1"].mean()),
        "@DurationSet2": float(df_filtered["@DurationSet2"].mean()),
        "precipitation": float(df_filtered["precipitation"].mean()),
        "rain": float(df_filtered["rain"].mean()),
        #"TeamFault_team": df_filtered["TeamFault_team"].mode()[0],
        "match_win": 1,  # Hier kannst du auch einen anderen Default-Wert verwenden
        "Team2": df_filtered["Team2"].unique()[0]
    }
elif model_choice =='Total-Spikes with weather impact (Gradient Boosting)':
    # Wetterparameter
    temperature_val = st.sidebar.slider("Temperature",  float(df_filtered["temperature_2m"].min()),  float(df_filtered["temperature_2m"].max()))
    wind_speed_val = st.sidebar.slider( "Wind Speed", float(df_filtered["wind_speed_10m"].min()), float(df_filtered["wind_speed_10m"].max()))
    wind_gusts_val = st.sidebar.slider( "Wind Gusts", float(df_filtered["wind_gusts_10m"].min()), float(df_filtered["wind_gusts_10m"].max()))

    # Abfrage, ob ein dritter Satz berücksichtigt werden soll
    third_set_selection = st.sidebar.selectbox("Third Set?", options=["No", "Yes"])
    third_set_value = 1 if third_set_selection == "Yes" else 0

    # Falls Third Set = Yes (also third_set_value==1), dann kann der Slider für DurationSet3 angezeigt werden.
    if third_set_value == 1:
        # Filtere den DataFrame basierend auf DurationSet3_indicator
        df_third_filtered = df_filtered[df_filtered["@DurationSet3_indicator"] == third_set_value]
        if not df_third_filtered.empty:
            duration_min = float(df_third_filtered['@DurationSet3'].min())
            duration_max = float(df_third_filtered['@DurationSet3'].max())
        else:
            duration_min, duration_max = 0.0, 0.0

        duration_val = st.sidebar.slider('Duration Set3', duration_min, duration_max)
    else:
        # Wenn kein Third Set ausgewählt wurde, setzen wir DurationSet3 automatisch auf 0
        duration_val = 0.0

    # Team-Auswahl (unabhängig vom Third Set Filter – oder auch hier ggf. anpassen)
    team1_selection = st.sidebar.selectbox("Team 1", df_filtered["Team1"].unique())

    # Zusammenstellung der Eingabedaten – beachte, dass die Schlüssel exakt den im Modell verwendeten Spaltennamen entsprechen müssen.
    input_data = {
        # Diese Felder werden interaktiv gefiltert:
        "temperature_2m": temperature_val,
        "wind_speed_10m": wind_speed_val,
        "wind_gusts_10m": wind_gusts_val,
        "@DurationSet3": duration_val,
        "@DurationSet3_indicator": third_set_value,
        "Team1": team1_selection,
        
        # Ergänzende Felder (Standardwerte aus df_filtered):
        "@PositionInEntry": float(df_filtered["@PositionInEntry"].mean()),
        "@Rank": int(df_filtered["@Rank"].median()),
        "@EarnedPointsTeam": float(df_filtered["@EarnedPointsTeam"].mean()),
        "@EarningsTotalTeam": float(df_filtered["@EarningsTotalTeam"].mean()),
        "Gender_x": df_filtered["Gender_x"].mode()[0],
        "Type": df_filtered["Type"].mode()[0],
        #"FederationCode_y": df_filtered["FederationCode_y"].mode()[0],
        "FirstName": df_filtered["FirstName"].iloc[0],
        "LastName": df_filtered["LastName"].iloc[0],
        "FirstName2": df_filtered["FirstName2"].iloc[0],
        "LastName2": df_filtered["LastName2"].iloc[0],
        "@DurationSet1": float(df_filtered["@DurationSet1"].mean()),
        "@DurationSet2": float(df_filtered["@DurationSet2"].mean()),
        "precipitation": float(df_filtered["precipitation"].mean()),
        "rain": float(df_filtered["rain"].mean()),
        #"TeamFault_team": df_filtered["TeamFault_team"].mode()[0],
        "match_win": 1,  # Hier kannst du auch einen anderen Default-Wert verwenden
        "Team2": df_filtered["Team2"].unique()[0]
    }
    


elif model_choice =='Total-Spikes without weather impact (Random Forest)':

    third_set_selection = st.sidebar.selectbox("Third Set Filter", options=["No", "Yes"])
    third_set_value = 1 if third_set_selection == "Yes" else 0

    # Falls Third Set = Yes (also third_set_value==1), dann kann der Slider für DurationSet3 angezeigt werden.
    if third_set_value == 1:
        # Filtere den DataFrame basierend auf DurationSet3_indicator
        df_third_filtered = df_filtered[df_filtered["@DurationSet3_indicator"] == third_set_value]
        if not df_third_filtered.empty:
            duration_min = float(df_third_filtered['@DurationSet3'].min())
            duration_max = float(df_third_filtered['@DurationSet3'].max())
        else:
            duration_min, duration_max = 0.0, 0.0

        duration_val = st.sidebar.slider('Duration Set3', duration_min, duration_max)
    else:
        # Wenn kein Third Set ausgewählt wurde, setzen wir DurationSet3 automatisch auf 0
        duration_val = 0.0
    duration1_val = st.sidebar.slider(
        'Duration Set1',
        float(df_filtered['@DurationSet1'].min()),
        float(df_filtered['@DurationSet1'].max())
    )
    duration2_val = st.sidebar.slider(
        'Duration Set2',
        float(df_filtered['@DurationSet2'].min()),
        float(df_filtered['@DurationSet2'].max())
    )
    # earnings_val = st.sidebar.slider(
    #     "EarningsTotalTeam", float(df_filtered["@EarningsTotalTeam"].min()), float(df_filtered["@EarningsTotalTeam"].max())
    # )

    team1_selection = st.sidebar.selectbox("Team 1", df_filtered["Team1"].unique())

    # Erstelle das input_data-Dictionary, das als Input für das Modell dient.
    input_data = {
        '@PositionInEntry': float(df_filtered['@PositionInEntry'].mean()),
        '@Rank': int(df_filtered['@Rank'].median()),
        '@EarnedPointsTeam': float(df_filtered['@EarnedPointsTeam'].mean()),
        '@EarningsTotalTeam': earnings_total_default,
        'Gender_x': df_filtered['Gender_x'].mode()[0],           # Häufigster Wert z. B.
        'Type': df_filtered['Type'].mode()[0],
        'FirstName': df_filtered['FirstName'].iloc[0],
        'LastName': df_filtered['LastName'].iloc[0],
        'FirstName2': df_filtered['FirstName2'].iloc[0],
        'LastName2': df_filtered['LastName2'].iloc[0],
        '@DurationSet1': duration1_val,
        '@DurationSet2': duration2_val,
        '@DurationSet3': duration_val,
        'match_win': 1,                                           # Beispiel: Standardwert für match_win
        'Team1': team1_selection,
        'Team2': df_filtered['Team2'].unique()[0],                # Beispiel: Erstes Team aus den Daten
        '@DurationSet3_indicator': third_set_value
    }




elif model_choice =='Total-Spikes without weather impact (Gradient Boosting)':
    # Abfrage: Soll der dritte Satz berücksichtigt werden (Filter)?
    third_set_selection = st.sidebar.selectbox("Third Set Filter", options=["No", "Yes"])
    third_set_value = 1 if third_set_selection == "Yes" else 0

    # Falls Third Set = Yes (also third_set_value==1), dann kann der Slider für DurationSet3 angezeigt werden.
    if third_set_value == 1:
        # Filtere den DataFrame basierend auf DurationSet3_indicator
        df_third_filtered = df_filtered[df_filtered["@DurationSet3_indicator"] == third_set_value]
        if not df_third_filtered.empty:
            duration_min = float(df_third_filtered['@DurationSet3'].min())
            duration_max = float(df_third_filtered['@DurationSet3'].max())
        else:
            duration_min, duration_max = 0.0, 0.0

        duration_val = st.sidebar.slider(
            'Duration Set3',
            duration_min,
            duration_max
        )
    else:
        # Wenn kein Third Set ausgewählt wurde, setzen wir DurationSet3 automatisch auf 0
        duration_val = 0.0
    duration1_val = st.sidebar.slider(
        'Duration Set1',
        float(df_filtered['@DurationSet1'].min()),
        float(df_filtered['@DurationSet1'].max())
    )
    duration2_val = st.sidebar.slider(
        'Duration Set2',
        float(df_filtered['@DurationSet2'].min()),
        float(df_filtered['@DurationSet2'].max())
    )
    # earnings_val = st.sidebar.slider(
    #     "EarningsTotalTeam", float(df_filtered["@EarningsTotalTeam"].min()), float(df_filtered["@EarningsTotalTeam"].max())
    # )

    team1_selection = st.sidebar.selectbox("Team 1", df_filtered["Team1"].unique())

    # Erstelle das input_data-Dictionary, das als Input für das Modell dient.
    input_data = {
        '@PositionInEntry': float(df_filtered['@PositionInEntry'].mean()),
        '@Rank': int(df_filtered['@Rank'].median()),
        '@EarnedPointsTeam': float(df_filtered['@EarnedPointsTeam'].mean()),
        '@EarningsTotalTeam': earnings_total_default,
        'Gender_x': df_filtered['Gender_x'].mode()[0],           # Häufigster Wert z. B.
        'Type': df_filtered['Type'].mode()[0],
        'FirstName': df_filtered['FirstName'].iloc[0],
        'LastName': df_filtered['LastName'].iloc[0],
        'FirstName2': df_filtered['FirstName2'].iloc[0],
        'LastName2': df_filtered['LastName2'].iloc[0],
        '@DurationSet1': duration1_val,
        '@DurationSet2': duration2_val,
        '@DurationSet3': duration_val,
        'match_win': 1,                                           # Beispiel: Standardwert für match_win
        'Team1': team1_selection,
        'Team2': df_filtered['Team2'].unique()[0],                # Beispiel: Erstes Team aus den Daten
        '@DurationSet3_indicator': third_set_value
    }

# Konvertiere Eingabe zu DataFrame
input_df = pd.DataFrame([input_data], columns=model.feature_names_in_)

#Vorhersage kommt erst, wenn Benutzer seine Eingaben bestätigt
if st.sidebar.button("Show Prediction"):#anpassen
    # Generate prediction
    prediction = model.predict(input_df)
    st.markdown(f"**Predicted Performance:** {prediction[0]:.2f}") 
    st.markdown("<br>" * 2, unsafe_allow_html=True)

#st.write("Bekannte Feature-Namen im Modell:", model.feature_names_in_)
#st.write("Eingabedaten:", list(input_data.keys()))
#----------------------------------------------------------------------
#test 
from sklearn.inspection import PartialDependenceDisplay
import matplotlib.pyplot as plt

if st.sidebar.button("Show PDP für Temperatur"):
    # 1. Feature-Index (oder name) auswählen
    df_filtered = df_filtered.rename(columns={'Team1':'Standard_Namen','Team2': 'Standard_Namen_team2'})
    
    feat = "temperature_2m"

    # 2. PDP zeichnen
    fig, ax = plt.subplots(figsize=(6, 4))
    PartialDependenceDisplay.from_estimator(
        model,
        X=df_filtered,                  # Trainings-DataFrame
        features=[feat],                # Liste von 1 oder mehreren Features
        kind="average",                 # Standard: "average" PDP
        grid_resolution=50,             # Anzahl Punkte entlang der Achse
        ax=ax
    )
    ax.set_title(f"PDP für '{feat}'")
    ax.set_ylabel("Prognostizierte Spike-Anzahl")
    ax.set_xlabel("Temperatur (°C)")

    # 3. In Streamlit anzeigen
    st.pyplot(fig)



# 1) 2D-Kontur-Heatmap: Temperatur vs. Wind Speed
if st.sidebar.button("Show 2D-Heatmap Temperatur vs. Wind"):
    df_filtered = df_filtered.rename(columns={'Team1':'Standard_Namen','Team2': 'Standard_Namen_team2'})
    # a) Erstelle Gitter für Temperatur und Wind Speed
    temp_vals = np.linspace(df_filtered["temperature_2m"].min(),
                            df_filtered["temperature_2m"].max(), 50)
    wind_vals = np.linspace(df_filtered["wind_speed_10m"].min(),
                            df_filtered["wind_speed_10m"].max(), 50)
    xx, yy = np.meshgrid(temp_vals, wind_vals)

    # b) Baue ein Template mit einer einzigen Zeile, die alle Features enthält
    template = df_filtered[model.feature_names_in_].iloc[[0]].copy()

    # c) Kachele das Template für jedes Gitter-Paar
    grid_df = pd.concat([template]*xx.size, ignore_index=True)

    # d) Überschreibe Temperatur und Wind Speed
    grid_df["temperature_2m"] = xx.ravel()
    grid_df["wind_speed_10m"] = yy.ravel()

    # e) Vorhersage auf dem Gitter
    zz = model.predict(grid_df).reshape(xx.shape)

    # f) Plot
    fig, ax = plt.subplots(figsize=(6, 5))
    contour = ax.contourf(xx, yy, zz, levels=20)
    fig.colorbar(contour, ax=ax, label="Predicted Spike-Anzahl")
    ax.set_xlabel("Temperature (°C)")
    ax.set_ylabel("Wind Speed (m/s)")
    ax.set_title("2D-Konturplot: Temperatur vs. Wind Speed")
    st.pyplot(fig)




#---------------------------------------------------------------------
if st.sidebar.button("Show influence of weather variables"):
    var_labels = {
    "temperature_2m": "Temperature (°C)",
    "wind_speed_10m": "Wind Speed (m/s)",
    "wind_gusts_10m": "Wind Gusts (m/s)",
    "rain": "Rain (mm)"
    }


    base_input = {
    "temperature_2m": st.session_state.get("temperature_val", float(df_filtered["temperature_2m"].mean())),
    "wind_speed_10m": st.session_state.get("wind_speed_val", float(df_filtered["wind_speed_10m"].mean())),
    "wind_gusts_10m": st.session_state.get("wind_gusts_val", float(df_filtered["wind_gusts_10m"].mean())),
    "rain": st.session_state.get("rain_val", float(df_filtered["rain"].mean())),
    "@DurationSet3": st.session_state.get("duration_val", 0.0),
    "@DurationSet3_indicator": st.session_state.get("third_set_value", 0),
    "Team1": st.session_state.get("team1_selection", df_filtered["Team1"].unique()[0])
    }

    # Definiere, welche Wettervariablen du untersuchen möchtest
    weather_vars = ["temperature_2m", "wind_speed_10m", "wind_gusts_10m", "rain"]

    #   Erstelle ein 2x2 Gitter für die Subplots
    fig = make_subplots(rows=2, cols=2)
    #, subplot_titles=[None] * len(weather_vars)
    # Für jede Wettervariable den Wertebereich bestimmen und darin Vorhersagen berechnen
    for i, var in enumerate(weather_vars):
        # Bestimme den Minimal- und Maximalwert aus deinen Daten
        vmin = float(df_filtered[var].min())
        vmax = float(df_filtered[var].max())
    
        # Erstelle ein Array mit Werten zwischen vmin und vmax (z.B. 100 Punkte)
        values = np.linspace(vmin, vmax, num=100)
        predictions = []

        # Für jeden Wert der aktuellen Wettervariable:
        for val in values:
            # Kopiere den Basis-Datensatz und setze den aktuellen Wetterwert
            current_input = base_input.copy()
            current_input[var] = val

            # Erstelle ein DataFrame, das die Reihenfolge der Features einhält, wie es dein Modell erwartet
            input_df = pd.DataFrame([current_input], columns=model.feature_names_in_)
        
            # Vorhersage des Modells (Anzahl der Spikes)
            prediction = model.predict(input_df)[0]
            predictions.append(prediction)
    
        # Bestimme die Position im Subplot-Gitter (2 Spalten)
        row = i // 2 + 1
        col = i % 2 + 1
    
        # Füge eine Linie zur entsprechenden Subplot hinzu
        fig.add_trace(
            px.line(x=values, y=predictions).data[0],
            row=row, col=col
            )
        # Achsentitel setzen
        fig.update_xaxes(title_text=var_labels.get(var, var), row=row, col=col)
        fig.update_yaxes(title_text="Predicted Spikes", row=row, col=col)

    # Passe das Layout an (Titel, Abstände, etc.)
    fig.update_layout(
        title_text="Influence of the weather for sum of Spikes",
        height=700, width=900,
        showlegend=False
    )

    st.plotly_chart(fig)

